#!/usr/bin/env/python
# -*- coding: UTF-8 -*-

'''
#if net = Network([8,3,8]),there be a network model:
	3 layers :
		net.layers[0] has 8 nodes / net.layers[1] has 3 nodes / net.layers[2] has 8 nodes
	2 connections:
		net.connections[0].downstream_nodes = [node_0_0,node_0_1,node_0_2,...]
		net.connections[1]....
# train_data / train_label generated by Normalize() , in this exampe:
	train_data = data_set:32 * 8

# Finally,correct_ratio used to evaluate this model's performance
				
'''
import random
from numpy import *

# activation funtion , sigmoid function here
def sigmoid(inX):
	return 1.0/(1 + exp(-inX))

class Node(object):
	def __init__(self,layer_index,node_index):
		# label the node's location
		self.layer_index = layer_index
		self.node_index = node_index
		# log the connection information the node has.
		self.downstream = []
		self.upstream = []
		# the result node calculated
		self.output = 0
		# for error information
		self.delta = 0

	def set_output(self,output):
		self.output = output

	def append_downstream_connection(self,conn):
		self.downstream.append(conn)

	def append_upstream_connection(self,conn):
		self.upstream.append(conn)

	def calc_output(self):
		# python_lambda syntax: lambda params : fuction_body 
		# python_reduce : sum_func
		output = reduce(lambda ret,conn : ret + conn.upstream_node.output * conn.weight,self.upstream,0)
		self.output = sigmoid(output)

	def calc_hidden_layer_delta(self):
		downstream_delta = reduce(
			lambda ret,conn:ret + conn.downstream_node.output*conn.weight,self.downstream,0.0)
		# back calculating metioned in algorithm
		self.delta = self.output *(1 - self.output)*downstream_delta

	def calc_output_layer_delta(self,label):
		# if the nodes represents the last layer.
		self.delta = self.output * (1 - self.output)*(label - self.output)

	def __str__(self):
		node_str = '%u-%u:output:%f delta:%f' % (self.layer_index,self.node_index,self.output,self.delta)
		downstream_str = reduce(lambda ret,conn:ret + '\n\t' + str(conn),self.downstream,'')
		upstream_str = reduce(lambda ret,conn:ret + '\n\t' + str(conn),self.upstream,'')
		return node_str + '\n\t downstream:'+downstream_str +'\n\t upstream:'+upstream_str


class ConstNode(object):
	#For a ConstNode, there is no upstream.
	def __init__(self, layer_index,node_index):
		self.layer_index = layer_index
		self.node_index = node_index
		self.downstream = []
		self.output = 1
	
	def append_downstream_connection(self,conn):
		self.downstream.append(conn)

	def calc_hidden_layer_delta(self):
		downstream_delta = reduce(
			lambda ret,conn:ret + conn.downstream_node.output*conn.weight,self.downstream,0.0)
		self.delta = self.output *(1 - self.output)*downstream_delta

	def __str__(self):
		node_str = '%u-%u:output: 1' % (self.layer_index,self.node_index)
		downstream_str = reduce(lambda ret,conn:ret + '\n\t' + str(conn),self.downstream,'')
		return node_str + '\n\t downstream:'+downstream_str


class Layer(object):
	def __init__(self,layer_index,node_count):
		self.layer_index = layer_index
		#A layer has many nodes saved in nodes
		self.nodes = []
		for i in range(node_count):
			self.nodes.append(Node(layer_index,i))
		# the last layer.
		self.nodes.append(ConstNode(layer_index,node_count))

	def set_output(self,data):
		# How many dimensions this layer_data has, how many nodes will be initialized.
		for i in range(len(data)):
			self.nodes[i].set_output(data[i])

	def calc_output(self):
		# For all nodes , calculate nodes' output.
		for node in self.nodes[:-1]:
			node.calc_output()

	def dump(self):
		for node in self.nodes :
			print node


class Connection(object):
	def __init__(self,upstream_node,downstream_node):
		self.upstream_node = upstream_node
		self.downstream_node = downstream_node
		self.weight = random.uniform(-0.1,0.1)
		self.gradient = 0.0

	def calc_gradient(self):
		self.gradient = self.downstream_node.delta * self.upstream_node.output

	def update_weight(self ,rate):
		self.calc_gradient()
		self.weight += rate * self.gradient

	def get_gradient(self):
		return self.gradient

	def __str__(self):
		return '(%u-%u) -> (%u-%u) = %f' % (
			self.upstream_node.layer_index,
			self.upstream_node.node_index,
			self.downstream_node.layer_index,
			self.downstream_node.node_index,
			self.weight)


class Connections(object):
	def __init__(self):
		self.connections = []

	def add_connection(self,connection):
		# All the connection the object has.
		self.connections.append(connection)

	def dump(self):
		for conn in self.connections:
			print conn


class Network(object):
	def __init__(self,layers):
		# connections: a list, element:connection(log connection info between upper_layer and latter_layer)
		self.connections = Connections()
		self.layers = []
		layer_count = len(layers)
		node_count = 0
		for i in range(layer_count):
			#layers in fullconnection have only one dimension
			self.layers.append(Layer(i,layers[i]))
		for layer in range(layer_count - 1):
			connections = [Connection(upstream_node,downstream_node)
							for upstream_node in self.layers[layer].nodes
							for downstream_node in self.layers[layer + 1].nodes[:-1]]
			for conn in connections:
				self.connections.add_connection(conn)
				conn.downstream_node.append_upstream_connection(conn)
				conn.upstream_node.append_downstream_connection(conn)

	def train(self,labels,data_set,rate,epoch):
		for i in range(epoch):
			for d in range(len(data_set)):
				# for every label and every data_set == n.
				self.train_one_sample(labels[d],data_set[d],rate)

	def train_one_sample(self,label,sample,rate):
		# label: 1 * 8 / sample: 1 * 8 , same as the number of nodes in 1st layer.
		self.predict(sample)
		self.calc_delta(label)
		self.update_weight(rate)

	def calc_delta(self,label):
		output_nodes = self.layers[-1].nodes
		for i in range(len(label)):
			output_nodes[i].calc_output_layer_delta(label[i])
		for layer in self.layers[-2::-1] :
			for node in layer.nodes:
				node.calc_hidden_layer_delta()

	def update_weight(self,rate):
		for layer in self.layers[:-1]:
			for node in layer.nodes:
				for conn in node.downstream:
					conn.update_weight(rate)

	def calc_gradient(self):
		for layer in self.layers[:-1]:
			for node in layer.nodes:
				for conn in node.downstream:
					conn.calc_gradient()

	def predict(self,sample):
		self.layers[0].set_output(sample)
		for i in range(1,len(self.layers)):
			self.layers[i].calc_output()
		return map(lambda node: node.output,self.layers[-1].nodes[:-1]) # layers[-1]:the final output.


	def dump(self):
		for layer in self.layers:
			layer.dump()


class Normalizer(object):
	def __init__(self):
		self.mask = [
			#binary: 0001 ,0010, 0100,1000,10000,100000,1000000,10000000
			0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x80
		]

	def norm(self,number):
		return map(lambda m:0.9 if number & m else 0.1,self.mask)  # &:and

	def denorm(self,vec):
		binary = map(lambda i: 1 if i > 0.5 else 0,vec)
		for i in range(len(self.mask)):
			binary[i] = binary[i] * self.mask[i]
		return reduce(lambda x,y:x + y,binary)

def mean_square_error(vec1,vec2):
	return 0.5 * reduce(lambda a,b:a + b,
			map(lambda v:(v[0] - v[1])*(v[0] - v[1])),
			zip(vec1,vec2))

def gradient_check(network,sample_feature,sample_label):
	network_error = lambda vec1,vec2:\
		0.5 * reduce(lambda a,b :a + b,
			map(lambda v :(v[0]-v[1])*(v[0] - v[1]),
				zip(vec1,vec2)))
	network.get_gradient(sample_feature,sample_label)
	for conn in network.connections.connections():
		actual_gradient = conn.get_gradient()

		epsilon = 0.0001
		conn.weight += epsilon
		error1 = network_error(network_predict(sample_feature),sample_label)

		conn.weight -= 2 * epsilon
		error2 = network_error(network_predict(sample_feature),sample_label)

		expected_gradient = (error2 - error1) / (2 *epsilon)

		print 'expected gradient : \t%f\nactual gradient : \t%f' % (
			expected_gradient , actual_gradient)

def train_data_set():
	# normalize.mask ,a list has 8 elements.
	normalizer = Normalizer()
	data_set = []
	labels = []
	for i in range(0,256,8): # 32 
		# each n is a list ,data_set/labels will have 2 dimensions
		n = normalizer.norm(int(random.uniform(0,256)))
		data_set.append(n) # 32 * 8 = 256
		labels.append(n) # 32 * 8 = 256
	return labels,data_set

def train(network):
	labels,data_set = train_data_set()
	network.train(labels,data_set , 0.3 , 50)

def test(network ,data):
	normalizer = Normalizer()
	norm_data = normalizer.norm(data)
	predict_data = network.predict(norm_data)
	print '\ttestdata(%u)\tpredict(%u)' % (
		data,normalizer.denorm(predict_data))

def correct_ratio(network):
	normalizer = Normalizer()
	correct = 0.0
	for i in range(256):
		'''
		#if net = Network([8,3,8]),there be a network model:
			3 layers :
				net.layers[0] has 8 nodes / net.layers[1] has 3 nodes / net.layers[2] has 8 nodes
			2 connections:
				net.connections[0].downstream_nodes = [node_0_0,node_0_1,node_0_2,...]
				net.connections[1]....
		# train_data / train_label generated by Normalize() , in this exampe:
			train_data = data_set:32 * 8

		# Finally,correct_ratio used to evaluate this model's performance
				
		'''
		if normalizer.denorm(network.predict(normalizer.norm(i))) == i:
			correct += 1.0
	print 'correct_ratio : %.2f%%' % (correct / 256 * 100)

def gradient_check_test():
	net = Network([2,2,2])
	sample_feature = [0.9,0.1]
	sample_label = [0.9,0.1]
	gradient_check(net , sample_feature,sample_label)



if __name__ == '__main__':
	net = Network([8,10,10])
	train(net)
	net.dump()
	correct_ratio(net)